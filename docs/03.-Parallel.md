# Parallel

```csharp
async Task ForAllAsync<T>(this ICollection<T>? collection, Func<T, CancellationToken, Task> body, CancellationToken token = default);
async Task ForAllAsync<T>(this ICollection<T>? collection, IAsyncAction<T> asyncAction, CancellationToken token = default);
```

The first overload from above performs similar to `Task.WhenAll`, except that it uses a rented buffer to allocate the tasks, overrides and overrides the function of to actually respect the cancellation token. Aside from the increased safety, for any function that isn't really async, i.e, returns a `CompletedTask`, this will provide greatly improved memory efficiency and will allocate about as much as completed `ValueTask`s.

The second overload is similar but uses `IAsyncAction<T>` instead of `Func<T, CancellationToken, Task>`, which allows for more flexibility. There isn't a performance difference between them, but `IAsyncAction<T>` can be implemented in a separate class, providing better variable management, and maintainability.
