# Collections

Sharpify has multiple custom collections such as:

## SortedList{T}

`SortedList<T>` is a re-implementation of `List<T>` with custom crud operations:

* Add -> O(log n)
* Remove -> O(log n)
* Get by sorted index O(1) - i.e min is [0] and max is [length - 1], also second max is [length - 2]...
* Option to disallow duplicates

The `SortedList<T>` also has convenience features, such as `AsSpan`, `Clear` methods, exposure of the `List<T>.Enumerator` which is an efficient struct, and also an implicit operator which can return the inner list in places which require `List<T>` (however be careful as the receiver may use the inner list and it may no longer maintain the features above)

## PersistentDictionary

`PersistentDictionary` is a thread-safe `Dictionary<string, string` that is optimized for concurrency. The abstract class provides most of the important implementation to allow all the features, and should be used as the type for the object when you want to use a `PersistentDictionary`.

`PersistentDictionary` has many convenience methods such as automatic conversions that allow getting any value that implements `IParsable` and adding any value that implements `IConvertible` which at the vary least are most of the primitive types in .NET

The main differences between the api of this and a regular dictionary is that it is best to use the async overloads

```csharp
// Upsert
public ValueTask UpsertAsync<T>(string key, T value) where T : struct, IConvertible
public virtual async ValueTask UpsertAsync(string key, string value)
// Retrieval
public async ValueTask<T> GetOrCreateAsync<T>(string key, T @default) where T : struct, IParsable<T>
public virtual async ValueTask<string> GetOrCreateAsync(string key, string @default)
```

you can also get values with a synchronous operation if you require by using `PersistentDictionary[key]`

but upsert is not available asynchronously due to the synchronization mechanisms that are used to optimize the concurrency

To configure the type for usage you can implement the class and it will show you the specific things required to make everything work. In addition, there are 2 built-in implementations:

* `LocalPersistentDictionary` is an implementation that serializes and restores the dictionary from a local path
* `LazyLocalPersistentDictionary` is an implementation that also serializes and restores the dictionary from a local path, doesn't maintain an in-memory version, allowing it to be garbage collected if it was even created, this is for very memory constrained scenarios. Reading from it, doesn't even create a dictionary.

## StringBuffer and AllocateStringBuffer

`StringBuffer` is a ref structs that efficiently encapsulates a `Span{char}` and allow very efficient appending of characters, strings and other `ISpanFormattable` implementations. It enables usage similar to that of `StringBuilder` but with a much lower memory footprint, and can work on stack allocated buffers.

It uses internal indexes to properly append elements, requiring no tracking from the user.

`StringBuffer` is created with a factory method named `Create(Span<char>)` that creates and returns an instance of `StringBuffer` with the specified buffer.

As it is a `ref struct`, it does have a default constructor, using it will create an instance on an empty buffer, that will throw an exception if you try to append anything to it. Please refrain from using it, it is only public because of compiler limitations.

### Appending

```csharp
ref TBuffer Append(char c);
ref TBuffer Append(ReadOnlySpan<char> str);
ref TBuffer Append<T>(T value, ReadOnlySpan<char> format = default, IFormatProvider? provider = null) where T : ISpanFormattable {}
ref TBuffer AppendLine();
ref TBuffer AppendLine(char c);
ref TBuffer AppendLine(ReadOnlySpan<char> str);
ref TBuffer AppendLine<T>(T value, ReadOnlySpan<char> format = default, IFormatProvider? provider = null) where T : ISpanFormattable {};
```

All the append methods return a reference to self, this is to enable usage of the builder pattern.

### Finalization

```csharp
// Will return the written portion of the buffer
WrittenSpan;
// Will create a string from the written portion of the buffer while removing end white spaces if they exist
Allocate(bool trimIfShorter, bool trimEndWhiteSpace);
Allocate(bool trimIfShorter); // ~ trimEndWhiteSpace = false
Allocate(); // ~ trimIfShorter = true, trimEndWhiteSpace = false
ToString() // Will call Allocate(true, false)
```

### Example

```csharp
public string GetHello() {
  var buffer = StringBuffer.Create(stackalloc char[50]);
  buffer.Append("Hello");
  buffer.Append(' ');
  buffer.Append("Everyone");
  buffer.Append('!');
  return buffer.Allocate();
  // We sample text is separated for api showcase.
}
// The returned result will be "Hello Everyone!"
```

```csharp
// Example of usage with the builder pattern - similar to StringBuilder
public string GetHello() {
  return StringBuffer.Create(stackalloc char[50])
                           .Append("Hello")
                           .Append(' ')
                           .Append("Everyone")
                           .Append('!')
                           .Allocate();
}
```

## RentedBufferWriter{T}

`RentedBufferWriter{T}` is an allocation friendly alternative to `ArrayBufferWriter{T}` which implements `IBufferWriter{T}`, an interface that represent a bucket that data can be written to. while it is not a commonly used interface, created to optimize specific hot paths, such as networking and IO pipes, using them is not very straightforward, and while `ArrayBufferWriter{T}` is a rather useful tool for some cases, it's limitation is that it isn't bound to any capacity, thus it always allocates arrays, and when it runs out of space, it allocates bigger arrays to resize, and that puts unneeded pressure of the GC.

`RentedBufferWriter{T}` fixes this by restricting the capacity at initialization, and renting the buffer from the shared array pool. Note that `SizeHint` in `GetSpan` and `GetMemory` is completely ignored in this implementation as resizing the inner buffer is currently not possible, by design. In case you are not sure what can exact capacity needed is, overestimate, it won't have much negative effects on the shared array pool.

Aside from implementing the interface `IBufferWriter{T}`, it also explicitly implements `IDisposable` to make sure the inner buffer is returned to the shared array pool after use. And implements many convenience methods and properties, such as:

```csharp
int ActualCapacity;
int FreeCapacity;
int Position { get; private set; }
ReadOnlySpan<T> WrittenSpan;
ReadOnlyMemory<T> WrittenMemory;
ArraySegment WrittenSegment;
ReadOnlySpan<T> GetSpanSlice(int start, int length);
ReadOnlyMemory<T> GetMemorySlice(int start, int length);
void Advance(int count);
bool WriteAndAdvance(T item);
bool WriteAndAdvance(ReadOnlySpan<T> data);
void Reset();
T[] Buffer; // Which returns the instance of the inner buffer, be careful with this.
ref T[] GetReferenceUnsafe(); // returns the reference for the inner buffer, be extra careful with this
```
