# CHANGELOG

* **BREAKING** `StringBuffer`s and `AllocatedStringBuffer`s constructor have been made internal, to enforce usage of the factory methods. The factory methods of both are now under `StringBuffer` and vary by name to indicate the type you are getting back. `StringBuffer.Rent(capacity)` will return a `StringBuffer` which rents memory from the array pool. And `StringBuffer.Create(Span{char})` will return an `AllocatedStringBuffer` which works on pre-allocated buffer. `StringBuffer` still implements `IDisposable` so should be used together with a `using` statement or keyword. Also, the implicit converters should now be prioritized to be inlined by the compiler.
  * It should be noted that in some cases **JetBrains Rider** marks it an error when the implicit operator to string is used in return statements of a method, this is not an actual error, it compiles and works fine, rather seems as an intellisense failure. If this bothers you, use `.Allocate(true)` instead, it does the same thing.
* Added a new 2 part access point for concurrency that is faster and more memory efficient for `IList` collections. Using the new extension method `AsLocalAsync` will wrap your `IList` in an async local, which guarantees it won't change in any async context, next use the extension method `ForEachAsync` similarly as before with an `IAsyncAction` implementation (preferably `sealed class`), it is also possible now to provide a `bool loadBalance` parameter, the default of which is `false`, and should be experimented with, as different tasks may require different values to perform at their peak. Using async local together with the restriction to IList, enables usage of higher performance internal apis, You can optimize non `IList` code such as `Dictionary` by renting a buffer from `ArrayPool` (which avoid can avoid memory allocations), copying the values to the buffer, then ensuring correct elements by using an `ArraySegment` of the buffer up the real length of the `Dictionary`, `ArraySegment` implements `IList` so now you now what to do... Don't forget to the return the buffer to the `ArrayPool` after it is no longer required.
* Added `Dictionary{K,V}.CopyTo((K,V)[], index)` extension (as built-in one isn't available without casting.)
